// flow.tsx
// C:\Users\ADM\Desktop\v13-main\pages\flow.tsx
import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import Link from 'next/link';
// --- CORRIGIDO: Importações diretas da UI ---
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Badge } from "@/components/ui/badge";
import { Textarea, TextareaProps } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";
// --- FIM CORREÇÃO ---
import { useToast } from "@/components/ui/use-toast"; // useToast geralmente tem seu próprio caminho
import { cn } from "@/lib/utils";
import { MessageSquare, ListChecks, Trash2 as IconTrash, Image as ImageIcon, Clock, Variable, Waypoints, HelpCircle, Users, Settings, Plus, RefreshCw, Send, RadioTower, UserCheck, LogOut, Save, Play, Square, Filter, Layers, Activity, Workflow, Target, Mic, File as FileIcon, MapPin, Repeat, Webhook, Sparkles, ArrowLeft, X } from 'lucide-react'; // Ícones
import { ReactFlow, MiniMap, Controls, Background, useNodesState, useEdgesState, addEdge, Node, Edge, OnConnect, BackgroundVariant, MarkerType, Position, Handle, NodeProps, XYPosition, useReactFlow, NodeTypes, ReactFlowProvider, ReactFlowInstance } from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import { FlowData, CampaignSelectItem, NodeContextMenuProps, ButtonOption, ListItem, ListSection } from '@/types/zap'; // Tipos compartilhados
import NodeContextMenu from '@/components/flow/NodeContextMenu';
import { IconWithGlow, NEON_COLOR, baseButtonSelectStyle, baseCardStyle, baseInputInsetStyle, popoverContentStyle } from '@/components/flow/utils'; // Utilitários/Estilos

// --- Componentes UI de Nós (Definidos aqui para simplicidade) ---
const NodeInput = (props: React.ComponentProps<typeof Input>) => <Input {...props} className={cn(baseInputInsetStyle, "text-[10px] h-6 px-1 py-0.5 rounded-sm", props.className)} />;
const NodeLabel = (props: React.ComponentProps<typeof Label>) => <Label {...props} className={cn("text-[9px] text-gray-400 mb-0.5 block", props.className)} style={{ textShadow: `0 0 3px ${NEON_COLOR}50` }}/>;
const NodeButton = (props: React.ComponentProps<typeof Button>) => <Button variant="outline" {...props} className={cn(baseButtonSelectStyle, `text-[9px] h-5 w-full rounded`, props.className)} style={{ textShadow: `0 0 4px ${NEON_COLOR}` }} />;
const NodeSelect = ({ children, ...props }: React.ComponentProps<typeof Select> & { placeholder?: string }) => ( <Select {...props}> <SelectTrigger className={cn(baseButtonSelectStyle, "h-6 text-[10px] rounded")}> <SelectValue placeholder={props.placeholder || 'Selecione...'} /> </SelectTrigger> <SelectContent className={cn(popoverContentStyle, "text-xs")}> {children} </SelectContent> </Select> );
// export interface NodeTextareaProps extends TextareaProps {} // TextareaProps já importado
const NodeTextarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>( ({ className, ...props }, ref) => {
    const autoResize = (element: HTMLTextAreaElement | null) => { if (element) { element.style.height = 'auto'; element.style.height = `${element.scrollHeight}px`; } };
    useEffect(() => { autoResize(ref && typeof ref !== 'function' ? ref.current : null); }, [props.value, ref]);
    const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { autoResize(e.target); if (props.onChange) { props.onChange(e); } };
    return ( <Textarea ref={ref} className={cn( baseInputInsetStyle, "text-[10px] resize-none overflow-hidden min-h-[30px] p-1 rounded-sm", className )} rows={1} {...props} onChange={handleChange} /> )
}); NodeTextarea.displayName = "NodeTextarea";


// --- Componentes de Nós (Cole as definições completas aqui - omitido para brevidade) ---
// function TextMessageNode({ id, data }: NodeProps<any>) { ... }
// function ButtonMessageNode({ id, data }: NodeProps<any>) { ... }
// ... (TODOS OS OUTROS COMPONENTES DE NÓ) ...
// --- INICIO COMPONENTES DE NÓS (COLE O CÓDIGO COMPLETO AQUI) ---
function TextMessageNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [text, setText] = useState(data?.text || ''); const textAreaRef = useRef<HTMLTextAreaElement>(null); const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { const newText = e.target.value; setText(newText); setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, text: newText } } : n)); }; return ( <Card className={cn(baseCardStyle, "node-card w-48")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600" /> <CardHeader className="node-header"> <div className="node-header-icon-title"><IconWithGlow icon={MessageSquare} /> Mensagem</div> </CardHeader> <CardContent className="p-2"> <NodeTextarea ref={textAreaRef} value={text} onChange={handleChange} placeholder="Sua mensagem..." /> </CardContent> <Handle type="source" position={Position.Bottom} id="source-bottom" isConnectable={true} className="!bg-gray-600"/> </Card> ); }
function ButtonMessageNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [text, setText] = useState(data?.text || ''); const [footer, setFooter] = useState(data?.footer || ''); const [buttons, setButtons] = useState<ButtonOption[]>(data?.buttons || [{ id: `btn_${Date.now()}`, text: 'Opção 1' }]); const textAreaRef = useRef<HTMLTextAreaElement>(null); const footerAreaRef = useRef<HTMLTextAreaElement>(null); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleTextChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { const newText = e.target.value; setText(newText); updateNodeData({ text: newText }); }; const handleFooterChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { const newFooter = e.target.value; setFooter(newFooter); updateNodeData({ footer: newFooter }); }; const handleButtonChange = (buttonId: string, newText: string) => { const newButtons = buttons.map(b => b.id === buttonId ? { ...b, text: newText } : b); setButtons(newButtons); updateNodeData({ buttons: newButtons }); }; const addButton = () => { const newButtonId = `btn_${Date.now()}_${Math.random().toString(16).substring(2, 6)}`; const newButtons = [...buttons, { id: newButtonId, text: `Opção ${buttons.length + 1}` }]; setButtons(newButtons); updateNodeData({ buttons: newButtons }); }
const removeButton = (buttonId: string) => { const newButtons = buttons.filter(b => b.id !== buttonId); setButtons(newButtons); updateNodeData({ buttons: newButtons }); }
return ( <Card className={cn(baseCardStyle, "node-card w-56")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={ListChecks} /> Botões</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Mensagem</NodeLabel> <NodeTextarea ref={textAreaRef} value={text} onChange={handleTextChange} placeholder="Mensagem com botões..." /> <NodeLabel>Rodapé (Opcional)</NodeLabel> <NodeTextarea ref={footerAreaRef} value={footer} onChange={handleFooterChange} placeholder="Texto rodapé..." /> <NodeLabel>Botões</NodeLabel> <div className='space-y-1 max-h-24 overflow-y-auto pr-1 custom-scrollbar'> {buttons.map((button, index) => ( <div key={button.id} className='relative group flex items-center'> <NodeInput value={button.text} onChange={(e) => handleButtonChange(button.id, e.target.value)} placeholder="Texto do Botão" className='flex-grow'/> <Handle type="source" position={Position.Right} id={button.id} style={{ top: `${(index + 0.5) * 28}px`, right: '-10px' }} className='!bg-teal-500 !h-2 !w-2 node-handle-glow' isConnectable={true}/> <Button onClick={() => removeButton(button.id)} variant="ghost" size="icon" className={cn(baseButtonSelectStyle, 'ml-1 flex-shrink-0 w-4 h-4 opacity-50 hover:opacity-100 !text-red-500 hover:!bg-red-500/20 rounded-sm')}><X className='w-3 h-3'/></Button> </div> ))} </div> <NodeButton onClick={addButton}><Plus className="mr-1 h-3 w-3"/> Adicionar Botão</NodeButton> </CardContent> </Card> ); }
function ImageNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [url, setUrl] = useState(data?.url || ''); const [caption, setCaption] = useState(data?.caption || ''); const captionAreaRef = useRef<HTMLTextAreaElement>(null); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }
const handleUrlChange = (e: React.ChangeEvent<HTMLInputElement>) => { setUrl(e.target.value); updateNodeData({ url: e.target.value }); }; const handleCaptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { setCaption(e.target.value); updateNodeData({ caption: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-52")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={ImageIcon} /> Imagem</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>URL da Imagem</NodeLabel> <NodeInput value={url} onChange={handleUrlChange} placeholder="https://..." /> <NodeLabel>Legenda (Opcional)</NodeLabel> <NodeTextarea ref={captionAreaRef} value={caption} onChange={handleCaptionChange} placeholder="Legenda..." /> </CardContent> <Handle type="source" position={Position.Bottom} id="source-bottom" isConnectable={true} className="!bg-gray-600"/> </Card> ); }
function DelayNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [duration, setDuration] = useState(data?.duration || 1); const [unit, setUnit] = useState<'seconds' | 'minutes'>(data?.unit || 'seconds'); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }
const handleDurationChange = (e: React.ChangeEvent<HTMLInputElement>) => { const val = parseInt(e.target.value) || 1; setDuration(val); updateNodeData({ duration: val }); }; const handleUnitChange = (value: 'seconds' | 'minutes') => { setUnit(value); updateNodeData({ unit: value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-40")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Clock} /> Atraso</div></CardHeader> <CardContent className="p-2 flex items-center space-x-1"> <NodeInput type="number" value={duration} onChange={handleDurationChange} className="w-16" min={1}/> <NodeSelect value={unit} onValueChange={handleUnitChange}> <SelectItem value="seconds" className='text-xs'>Segundos</SelectItem> <SelectItem value="minutes" className='text-xs'>Minutos</SelectItem> </NodeSelect> </CardContent> <Handle type="source" position={Position.Bottom} id="source-bottom" isConnectable={true} className="!bg-gray-600"/> </Card> ); }
function ListMessageNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [buttonText, setButtonText] = useState(data?.buttonText || 'Opções'); const [title, setTitle] = useState(data?.title || 'Título da Lista'); const [body, setBody] = useState(data?.text || ''); const [footer, setFooter] = useState(data?.footer || ''); const [sections, setSections] = useState<ListSection[]>(data?.sections || [{id:`sec_${Date.now()}`, title:'Seção 1', rows:[{id:`row_${Date.now()}`, title:'Item 1'}]}]); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }
return ( <Card className={cn(baseCardStyle, "node-card w-64")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={ListChecks} className="text-cyan-400"/> Lista</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Texto Botão</NodeLabel> <NodeInput value={buttonText} onChange={(e) => { setButtonText(e.target.value); updateNodeData({ buttonText: e.target.value }); }} placeholder="Texto do Botão..." /> <NodeLabel>Título Lista</NodeLabel> <NodeInput value={title} onChange={(e) => { setTitle(e.target.value); updateNodeData({ title: e.target.value }); }} placeholder="Título..." /> <NodeLabel>Corpo (Opcional)</NodeLabel> <NodeTextarea value={body} onChange={(e) => { setBody(e.target.value); updateNodeData({ text: e.target.value }); }} placeholder="Descrição da lista..." /> <NodeLabel>Rodapé (Opcional)</NodeLabel> <NodeTextarea value={footer} onChange={(e) => { setFooter(e.target.value); updateNodeData({ footer: e.target.value }); }} placeholder="Texto rodapé..." /> <NodeLabel>Seções/Itens (Simplificado)</NodeLabel> <div className={cn(baseInputInsetStyle, 'text-[9px] text-gray-400 p-1 min-h-[20px] max-h-20 overflow-y-auto custom-scrollbar rounded-sm')}> {sections.map((s, sIdx) => ( <div key={s.id}> <strong className='text-[10px] text-gray-300'>{s.title || `Seção ${sIdx + 1}`}</strong>: {s.rows.map((r:ListItem) => r.title || 'Item').join(', ')} </div> ))} </div> </CardContent> {sections.flatMap((section, sIdx) => section.rows.map((row:ListItem, rIdx: number) => ( <Handle key={row.id} type="source" position={Position.Right} id={row.id} style={{ top: `${40 + sIdx * 20 + rIdx * 10}%`, right: '-10px' }} className='!bg-cyan-500 !h-2 !w-2 node-handle-glow' title={row.title || `Item ${rIdx + 1}`} isConnectable={true} /> )))} <Handle type="source" position={Position.Bottom} id="source-fallback" style={{ bottom: '-10px', left: '50%' }} className='!bg-orange-500 !h-2 !w-2 node-handle-glow' title="Fallback (Sem seleção)" isConnectable={true}/> </Card> ); }
function WaitInputNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [variableName, setVariableName] = useState(data?.variableName || 'userInput'); const [message, setMessage] = useState(data?.message || ''); const [timeoutSeconds, setTimeoutSeconds] = useState<number | undefined>(data?.timeoutSeconds); const textAreaRef = useRef<HTMLTextAreaElement>(null); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }
const handleVarChange = (e: React.ChangeEvent<HTMLInputElement>) => { setVariableName(e.target.value); updateNodeData({ variableName: e.target.value }); }; const handleMsgChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { setMessage(e.target.value); updateNodeData({ message: e.target.value }); }; const handleTimeoutChange = (e: React.ChangeEvent<HTMLInputElement>) => { const val = e.target.value ? parseInt(e.target.value, 10) : undefined; setTimeoutSeconds(val); updateNodeData({ timeoutSeconds: val }); }; return ( <Card className={cn(baseCardStyle, "node-card w-52")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={HelpCircle} /> Esperar Input</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Salvar em Variável</NodeLabel> <NodeInput value={variableName} onChange={handleVarChange} placeholder="nome_variavel" /> <NodeLabel>Mensagem (Opcional)</NodeLabel> <NodeTextarea ref={textAreaRef} value={message} onChange={handleMsgChange} placeholder="Ex: Digite seu nome..." /> <NodeLabel>Timeout (Segundos, Opcional)</NodeLabel> <NodeInput type="number" value={timeoutSeconds ?? ''} onChange={handleTimeoutChange} placeholder="Ex: 60" min={1} /> </CardContent> <Handle type="source" position={Position.Bottom} id="source-received" title="Recebido" isConnectable={true} className="!bg-gray-600"/> <Handle type="source" position={Position.Right} id="source-timeout" style={{ top: '65%', right: '-10px' }} className='!bg-orange-500 !h-2 !w-2 node-handle-glow' title="Timeout" isConnectable={!!timeoutSeconds}/> </Card> ); }
function SetVariableNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [variableName, setVariableName] = useState(data?.variableName || 'myVar'); const [value, setValue] = useState(data?.value || ''); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }
const handleVarChange = (e: React.ChangeEvent<HTMLInputElement>) => { setVariableName(e.target.value); updateNodeData({ variableName: e.target.value }); }; const handleValueChange = (e: React.ChangeEvent<HTMLInputElement>) => { setValue(e.target.value); updateNodeData({ value: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-52")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Variable} /> Definir Variável</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Nome da Variável</NodeLabel> <NodeInput value={variableName} onChange={handleVarChange} placeholder="nome_variavel" /> <NodeLabel>Valor (Use {'{{var}}'} para outras vars)</NodeLabel> <NodeInput value={value} onChange={handleValueChange} placeholder={'Valor ou {{outra_var}}'} /> </CardContent> <Handle type="source" position={Position.Bottom} id="source-bottom" isConnectable={true} className="!bg-gray-600"/> </Card> ); }
function ConditionNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [variableName, setVariableName] = useState(data?.variableName || ''); const [comparison, setComparison] = useState<any>(data?.comparison || 'equals'); const [value, setValue] = useState(data?.value || ''); const showValueInput = !['isSet', 'isNotSet'].includes(comparison); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleVarChange = (e: React.ChangeEvent<HTMLInputElement>) => { setVariableName(e.target.value); updateNodeData({ variableName: e.target.value }); }; const handleCompChange = (val: any) => { setComparison(val); updateNodeData({ comparison: val, value: ['isSet', 'isNotSet'].includes(val) ? '' : value }); }; const handleValueChange = (e: React.ChangeEvent<HTMLInputElement>) => { setValue(e.target.value); updateNodeData({ value: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-56")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Waypoints} /> Condição</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Variável</NodeLabel> <NodeInput value={variableName} onChange={handleVarChange} placeholder="nome_variavel" /> <NodeLabel>Comparação</NodeLabel> <NodeSelect value={comparison} onValueChange={handleCompChange}> <SelectItem value="equals" className='text-xs'>Igual a</SelectItem> <SelectItem value="contains" className='text-xs'>Contém</SelectItem> <SelectItem value="startsWith" className='text-xs'>Começa com</SelectItem> <SelectItem value="isSet" className='text-xs'>Está Definida</SelectItem> <SelectItem value="isNotSet" className='text-xs'>Não Definida</SelectItem> <SelectItem value="greaterThan" className='text-xs'>Maior que (Num)</SelectItem> <SelectItem value="lessThan" className='text-xs'>Menor que (Num)</SelectItem> </NodeSelect> {showValueInput && <> <NodeLabel>Valor (Use {'{{var}}'})</NodeLabel> <NodeInput value={value} onChange={handleValueChange} placeholder={'Valor ou {{outra_var}}'} /> </>} </CardContent> <Handle type="source" position={Position.Right} id="source-true" style={{ top: '35%', right: '-10px' }} className='!bg-green-500 !h-2 !w-2 node-handle-glow' title="Verdadeiro" isConnectable={true}/> <Handle type="source" position={Position.Right} id="source-false" style={{ top: '65%', right: '-10px' }} className='!bg-red-500 !h-2 !w-2 node-handle-glow' title="Falso" isConnectable={true}/> </Card> ); }
function ApiCallNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [apiUrl, setApiUrl] = useState(data?.apiUrl || ''); const [method, setMethod] = useState<any>(data?.method || 'GET'); const [headers, setHeaders] = useState(data?.headers || ''); const [body, setBody] = useState(data?.body || ''); const [saveResponseTo, setSaveResponseTo] = useState(data?.saveResponseTo || ''); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleUrlChange = (e: React.ChangeEvent<HTMLInputElement>) => { setApiUrl(e.target.value); updateNodeData({ apiUrl: e.target.value }); }; const handleMethodChange = (val: any) => { setMethod(val); updateNodeData({ method: val }); }; const handleHeadersChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { setHeaders(e.target.value); updateNodeData({ headers: e.target.value }); }; const handleBodyChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { setBody(e.target.value); updateNodeData({ body: e.target.value }); }; const handleSaveVarChange = (e: React.ChangeEvent<HTMLInputElement>) => { setSaveResponseTo(e.target.value); updateNodeData({ saveResponseTo: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-60")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={RadioTower} /> API Call</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>URL (Use {'{{var}}'})</NodeLabel> <NodeInput value={apiUrl} onChange={handleUrlChange} placeholder="https://api.exemplo.com/..." /> <NodeLabel>Método</NodeLabel> <NodeSelect value={method} onValueChange={handleMethodChange}> <SelectItem value="GET" className='text-xs'>GET</SelectItem> <SelectItem value="POST" className='text-xs'>POST</SelectItem> <SelectItem value="PUT" className='text-xs'>PUT</SelectItem> <SelectItem value="DELETE" className='text-xs'>DELETE</SelectItem> </NodeSelect> <NodeLabel>Headers (JSON, Opcional)</NodeLabel> <NodeTextarea value={headers} onChange={handleHeadersChange} placeholder='{"Content-Type": "application/json"}' /> <NodeLabel>Body (JSON/Texto, Opcional)</NodeLabel> <NodeTextarea value={body} onChange={handleBodyChange} placeholder='{"key": "{{var}}"}' /> <NodeLabel>Salvar Resposta em (Opcional)</NodeLabel> <NodeInput value={saveResponseTo} onChange={handleSaveVarChange} placeholder="nome_variavel_resposta" /> </CardContent> <Handle type="source" position={Position.Bottom} id="source-success" title="Sucesso" isConnectable={true} className="!bg-gray-600"/> <Handle type="source" position={Position.Right} id="source-error" style={{ top: '50%', right: '-10px' }} className='!bg-red-500 !h-2 !w-2 node-handle-glow' title="Erro" isConnectable={true}/> </Card> ); }
function AssignAgentNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [department, setDepartment] = useState(data?.department || ''); const [message, setMessage] = useState(data?.message || ''); const textAreaRef = useRef<HTMLTextAreaElement>(null); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleDeptChange = (e: React.ChangeEvent<HTMLInputElement>) => { setDepartment(e.target.value); updateNodeData({ department: e.target.value }); }; const handleMsgChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { setMessage(e.target.value); updateNodeData({ message: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-52")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={UserCheck} /> Atribuir Agente</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Departamento (Opcional)</NodeLabel> <NodeInput value={department} onChange={handleDeptChange} placeholder="Ex: Vendas" /> <NodeLabel>Mensagem Inicial (Opcional)</NodeLabel> <NodeTextarea ref={textAreaRef} value={message} onChange={handleMsgChange} placeholder="Mensagem para o agente..." /> </CardContent> </Card> ); }
function EndFlowNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [reason, setReason] = useState(data?.reason || ''); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleReasonChange = (e: React.ChangeEvent<HTMLInputElement>) => { setReason(e.target.value); updateNodeData({ reason: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-40")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={LogOut} className="text-red-500" /> Encerrar</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Motivo (Opcional)</NodeLabel> <NodeInput value={reason} onChange={handleReasonChange} placeholder="Motivo do fim"/> </CardContent> </Card> ); }
function GoToFlowNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [targetFlowId, setTargetFlowId] = useState(data?.targetFlowId || ''); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleIdChange = (e: React.ChangeEvent<HTMLInputElement>) => { setTargetFlowId(e.target.value); updateNodeData({ targetFlowId: e.target.value }); }
return ( <Card className={cn(baseCardStyle, "node-card w-48")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Workflow} /> Ir p/ Fluxo</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>ID do Fluxo de Destino</NodeLabel> <NodeInput value={targetFlowId} onChange={handleIdChange} placeholder="ID numérico" /> </CardContent> </Card> ); }
function TagContactNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [tagName, setTagName] = useState(data?.tagName || ''); const [action, setAction] = useState<'add' | 'remove'>(data?.action || 'add'); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleTagChange = (e: React.ChangeEvent<HTMLInputElement>) => { setTagName(e.target.value); updateNodeData({ tagName: e.target.value }); }; const handleActionChange = (val: 'add' | 'remove') => { setAction(val); updateNodeData({ action: val }); }; return ( <Card className={cn(baseCardStyle, "node-card w-48")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Target} /> Tag Contato</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Nome da Tag</NodeLabel> <NodeInput value={tagName} onChange={handleTagChange} placeholder="Ex: Lead Qualificado" /> <NodeLabel>Ação</NodeLabel> <NodeSelect value={action} onValueChange={handleActionChange}> <SelectItem value="add" className='text-xs'>Adicionar Tag</SelectItem> <SelectItem value="remove" className='text-xs'>Remover Tag</SelectItem> </NodeSelect> </CardContent> <Handle type="source" position={Position.Bottom} id="source-bottom" isConnectable={true} className="!bg-gray-600"/> </Card> ); }
function AudioMessageNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [url, setUrl] = useState(data?.url || ''); const [caption, setCaption] = useState(data?.caption || ''); const captionAreaRef = useRef<HTMLTextAreaElement>(null); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleUrlChange = (e: React.ChangeEvent<HTMLInputElement>) => { setUrl(e.target.value); updateNodeData({ url: e.target.value }); }; const handleCaptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { setCaption(e.target.value); updateNodeData({ caption: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-52")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Mic} /> Áudio</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>URL do Áudio</NodeLabel> <NodeInput value={url} onChange={handleUrlChange} placeholder="https://..." /> <NodeLabel>Legenda (Opcional)</NodeLabel> <NodeTextarea ref={captionAreaRef} value={caption} onChange={handleCaptionChange} placeholder="Legenda..." /> </CardContent> <Handle type="source" position={Position.Bottom} id="source-bottom" isConnectable={true} className="!bg-gray-600"/> </Card> ); }
function FileMessageNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [url, setUrl] = useState(data?.url || ''); const [filename, setFilename] = useState(data?.filename || ''); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleUrlChange = (e: React.ChangeEvent<HTMLInputElement>) => { setUrl(e.target.value); updateNodeData({ url: e.target.value }); }; const handleFilenameChange = (e: React.ChangeEvent<HTMLInputElement>) => { setFilename(e.target.value); updateNodeData({ filename: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-52")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={FileIcon} /> Arquivo</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>URL do Arquivo</NodeLabel> <NodeInput value={url} onChange={handleUrlChange} placeholder="https://..." /> <NodeLabel>Nome do Arquivo (Opcional)</NodeLabel> <NodeInput value={filename} onChange={handleFilenameChange} placeholder="Ex: documento.pdf"/> </CardContent> <Handle type="source" position={Position.Bottom} id="source-bottom" isConnectable={true} className="!bg-gray-600"/> </Card> ); }
function LocationMessageNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [latitude, setLatitude] = useState(data?.latitude || ''); const [longitude, setLongitude] = useState(data?.longitude || ''); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleLatChange = (e: React.ChangeEvent<HTMLInputElement>) => { setLatitude(e.target.value); updateNodeData({ latitude: e.target.value }); }; const handleLonChange = (e: React.ChangeEvent<HTMLInputElement>) => { setLongitude(e.target.value); updateNodeData({ longitude: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-52")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={MapPin} /> Localização</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Latitude</NodeLabel> <NodeInput value={latitude} onChange={handleLatChange} placeholder="-23.5505" /> <NodeLabel>Longitude</NodeLabel> <NodeInput value={longitude} onChange={handleLonChange} placeholder="-46.6333"/> </CardContent> <Handle type="source" position={Position.Bottom} id="source-bottom" isConnectable={true} className="!bg-gray-600"/> </Card> ); }
function TimeConditionNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [startTime, setStartTime] = useState(data?.startTime || '09:00'); const [endTime, setEndTime] = useState(data?.endTime || '18:00'); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleStartChange = (e: React.ChangeEvent<HTMLInputElement>) => { setStartTime(e.target.value); updateNodeData({ startTime: e.target.value }); }; const handleEndChange = (e: React.ChangeEvent<HTMLInputElement>) => { setEndTime(e.target.value); updateNodeData({ endTime: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-52")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Clock} /> Condição Horário</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Hora Início (HH:MM)</NodeLabel> <NodeInput type="time" value={startTime} onChange={handleStartChange} /> <NodeLabel>Hora Fim (HH:MM)</NodeLabel> <NodeInput type="time" value={endTime} onChange={handleEndChange} /> </CardContent> <Handle type="source" position={Position.Right} id="source-inside" style={{ top: '35%', right: '-10px' }} className='!bg-green-500 !h-2 !w-2 node-handle-glow' title="Dentro Horário" isConnectable={true}/> <Handle type="source" position={Position.Right} id="source-outside" style={{ top: '65%', right: '-10px' }} className='!bg-red-500 !h-2 !w-2 node-handle-glow' title="Fora Horário" isConnectable={true}/> </Card> ); }
function LoopNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [repetitions, setRepetitions] = useState(data?.repetitions || 3); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleRepChange = (e: React.ChangeEvent<HTMLInputElement>) => { const val = parseInt(e.target.value) || 1; setRepetitions(val); updateNodeData({ repetitions: val }); }; return ( <Card className={cn(baseCardStyle, "node-card w-40")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Repeat} /> Loop</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Repetições</NodeLabel> <NodeInput type="number" value={repetitions} onChange={handleRepChange} min={1} /> </CardContent> <Handle type="source" position={Position.Right} id="source-loop-body" style={{ top: '35%', right: '-10px' }} className='!bg-blue-500 !h-2 !w-2 node-handle-glow' title="Corpo Loop" isConnectable={true}/> <Handle type="source" position={Position.Right} id="source-finished" style={{ top: '65%', right: '-10px' }} className='!bg-gray-600 !h-2 !w-2' title="Finalizado" isConnectable={true}/> </Card> ); }
function WebhookCallNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [url, setUrl] = useState(data?.url || ''); const [method, setMethod] = useState<any>(data?.method || 'POST'); const [headers, setHeaders] = useState(data?.headers || ''); const [body, setBody] = useState(data?.body || ''); const [saveResponseTo, setSaveResponseTo] = useState(data?.saveResponseTo || ''); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleUrlChange = (e: React.ChangeEvent<HTMLInputElement>) => { setUrl(e.target.value); updateNodeData({ url: e.target.value }); }; const handleMethodChange = (val: any) => { setMethod(val); updateNodeData({ method: val }); }; const handleHeadersChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { setHeaders(e.target.value); updateNodeData({ headers: e.target.value }); }; const handleBodyChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { setBody(e.target.value); updateNodeData({ body: e.target.value }); }; const handleSaveVarChange = (e: React.ChangeEvent<HTMLInputElement>) => { setSaveResponseTo(e.target.value); updateNodeData({ saveResponseTo: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-60")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Webhook} /> Webhook</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>URL (Use {'{{var}}'})</NodeLabel> <NodeInput value={url} onChange={handleUrlChange} placeholder="https://seu.webhook/..." /> <NodeLabel>Método</NodeLabel> <NodeSelect value={method} onValueChange={handleMethodChange}> <SelectItem value="POST" className='text-xs'>POST</SelectItem> <SelectItem value="GET" className='text-xs'>GET</SelectItem> </NodeSelect> <NodeLabel>Headers (JSON, Opcional)</NodeLabel> <NodeTextarea value={headers} onChange={handleHeadersChange} placeholder='{"Authorization": "Bearer ..."}' /> <NodeLabel>Body (JSON/Texto, {'{{var}}'}, Opcional)</NodeLabel> <NodeTextarea value={body} onChange={handleBodyChange} placeholder='{"message": "{{userInput}}"}' /> <NodeLabel>Salvar Resposta em (Opcional)</NodeLabel> <NodeInput value={saveResponseTo} onChange={handleSaveVarChange} placeholder="nome_variavel_webhook" /> </CardContent> <Handle type="source" position={Position.Bottom} id="source-success" title="Sucesso" isConnectable={true} className="!bg-gray-600"/> <Handle type="source" position={Position.Right} id="source-error" style={{ top: '50%', right: '-10px' }} className='!bg-red-500 !h-2 !w-2 node-handle-glow' title="Erro" isConnectable={true}/> </Card> ); }
function GPTQueryNode({ id, data }: NodeProps<any>) { const { setNodes } = useReactFlow(); const [prompt, setPrompt] = useState(data?.prompt || ''); const [apiKeyVariable, setApiKeyVariable] = useState(data?.apiKeyVariable || 'OPENAI_API_KEY'); const [saveResponseTo, setSaveResponseTo] = useState(data?.saveResponseTo || 'gptResponse'); const promptAreaRef = useRef<HTMLTextAreaElement>(null); const updateNodeData = (newData: any) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handlePromptChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { setPrompt(e.target.value); updateNodeData({ prompt: e.target.value }); }; const handleApiKeyVarChange = (e: React.ChangeEvent<HTMLInputElement>) => { setApiKeyVariable(e.target.value); updateNodeData({ apiKeyVariable: e.target.value }); }; const handleSaveVarChange = (e: React.ChangeEvent<HTMLInputElement>) => { setSaveResponseTo(e.target.value); updateNodeData({ saveResponseTo: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-64")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Sparkles} /> Consulta GPT</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Prompt (Use {'{{var}}'})</NodeLabel> <NodeTextarea ref={promptAreaRef} value={prompt} onChange={handlePromptChange} placeholder="Ex: Qual a capital da {{pais}}?" /> <NodeLabel>Variável da API Key OpenAI</NodeLabel> <NodeInput value={apiKeyVariable} onChange={handleApiKeyVarChange} placeholder="Ex: OPENAI_API_KEY" /> <NodeLabel>Salvar Resposta em</NodeLabel> <NodeInput value={saveResponseTo} onChange={handleSaveVarChange} placeholder="nome_variavel_gpt" /> </CardContent> <Handle type="source" position={Position.Bottom} id="source-success" title="Sucesso" isConnectable={true} className="!bg-gray-600"/> <Handle type="source" position={Position.Right} id="source-error" style={{ top: '50%', right: '-10px' }} className='!bg-red-500 !h-2 !w-2 node-handle-glow' title="Erro" isConnectable={true}/> </Card> ); }
// --- FIM COMPONENTES DE NÓS ---


// --- Componente da Página do Editor ---
function FlowEditorPage() {
    const [nodes, setNodes, onNodesChange] = useNodesState([]);
    const [edges, setEdges, onEdgesChange] = useEdgesState([]);
    const reactFlowInstance = useReactFlow<any, any>();
    const { toast } = useToast();
    const [flowsList, setFlowsList] = useState<FlowData[]>([]);
    const [campaignList, setCampaignList] = useState<CampaignSelectItem[]>([]);
    const [selectedFlow, setSelectedFlow] = useState<FlowData | null>(null);
    const [flowNameInput, setFlowNameInput] = useState('');
    const [selectedCampaignId, setSelectedCampaignId] = useState<string | null>(null);
    const [filterCampaignId, setFilterCampaignId] = useState<string | 'all'>('all');
    const reactFlowWrapper = useRef<HTMLDivElement>(null);
    const [contextMenu, setContextMenu] = useState<NodeContextMenuProps | null>(null);
    const [isLoadingFlowList, setIsLoadingFlowList] = useState(true);
    const [isLoadingFlowDetails, setIsLoadingFlowDetails] = useState(false);
    const [isSaving, setIsSaving] = useState(false);
    const [isDeleting, setIsDeleting] = useState(false);
    const [isTogglingStatus, setIsTogglingStatus] = useState(false);
    const [initialFlowLoaded, setInitialFlowLoaded] = useState(false);

    // Mapeamento de tipos de nós para componentes
    const nodeTypes = useMemo(() => ({
        textMessage: TextMessageNode, buttonMessage: ButtonMessageNode, imageMessage: ImageNode,
        delay: DelayNode, listMessage: ListMessageNode, waitInput: WaitInputNode,
        setVariable: SetVariableNode, condition: ConditionNode, apiCall: ApiCallNode,
        assignAgent: AssignAgentNode, endFlow: EndFlowNode, goToFlow: GoToFlowNode,
        tagContact: TagContactNode, audioMessage: AudioMessageNode, fileMessage: FileMessageNode,
        locationMessage: LocationMessageNode, timeCondition: TimeConditionNode, loopNode: LoopNode,
        webhookCall: WebhookCallNode, gptQuery: GPTQueryNode,
    }), []);

    // --- Funções de Lógica (Cole aqui - omitido para brevidade) ---
    // const fetchCampaigns = useCallback(...)
    // const loadFlow = useCallback(...)
    // const fetchFlows = useCallback(...)
    // const saveFlow = useCallback(...)
    // const createNewFlow = useCallback(...)
    // const deleteSelectedFlow = useCallback(...)
    // const toggleFlowStatus = useCallback(...)
    // const onConnect = useCallback(...)
    // const handleNodeContextMenu = useCallback(...)
    // const handlePaneClick = useCallback(...)
    // const handleDeleteNode = useCallback(...)
    // const handleDuplicateNode = useCallback(...)
    // const addNode = useCallback(...)
    // --- INICIO FUNÇÕES E HOOKS (COLE O CÓDIGO COMPLETO AQUI) ---
    const fetchCampaigns = useCallback(async () => { try { const response = await fetch('/api/campaigns'); if (!response.ok) throw new Error('Falha ao buscar campanhas'); const data: CampaignSelectItem[] = await response.json(); setCampaignList(data); } catch (error: any) { toast({ title: "Erro Campanhas", description: error.message, variant: "destructive" }); setCampaignList([]); } }, [toast]);
    const loadFlow = useCallback(async (flowId: number | string | null) => { if (!flowId || isLoadingFlowDetails || (typeof flowId === 'string' && isNaN(parseInt(flowId)))) { if (!flowId && selectedFlow !== null) { setSelectedFlow(null); setNodes([]); setEdges([]); setFlowNameInput(''); setSelectedCampaignId(null); } return; } const idNum = typeof flowId === 'string' ? parseInt(flowId) : flowId; if(selectedFlow?.id === idNum && initialFlowLoaded) { return; } setIsLoadingFlowDetails(true); setContextMenu(null); try { const response = await fetch(`/api/flows?id=${idNum}`);
        if (!response.ok) { if (response.status === 404) { toast({ title: "Aviso", description: `Fluxo ID ${idNum} não encontrado.`, variant: "default" }); setSelectedFlow(null); setNodes([]); setEdges([]); setFlowNameInput(''); setSelectedCampaignId(null); } else { const err = await response.json(); throw new Error(err.message || `Falha (status ${response.status})`); } return; } const flow: FlowData = await response.json(); setSelectedFlow(flow); setFlowNameInput(flow.name); setSelectedCampaignId(flow.campaign_id ?? null); const flowElements = flow.elements || { nodes: [], edges: [] }; const nodesArray = Array.isArray(flowElements.nodes) ? flowElements.nodes : []; const edgesArray = Array.isArray(flowElements.edges) ? flowElements.edges : []; const nodesWithHandle = nodesArray.map(n => ({ ...n, dragHandle: '.node-header' })); setNodes(nodesWithHandle); setEdges(edgesArray); setInitialFlowLoaded(true); if (reactFlowInstance) { setTimeout(() => { try { reactFlowInstance.fitView({ duration: 400, padding: 0.2 }); } catch(e) { console.error("[loadFlow] Erro fitView:", e); } }, 100); } } catch (error: any) { console.error(`[loadFlow] Erro ID ${idNum}:`, error); toast({ title: "Erro ao Carregar Fluxo", description: error.message, variant: "destructive" }); setSelectedFlow(null); setNodes([]); setEdges([]); setFlowNameInput(''); setSelectedCampaignId(null); if(reactFlowInstance) setTimeout(() => reactFlowInstance.fitView({duration: 200}), 50); } finally { setIsLoadingFlowDetails(false); } }, [ setNodes, setEdges, toast, isLoadingFlowDetails, reactFlowInstance, selectedFlow?.id, initialFlowLoaded]);
    const fetchFlows = useCallback(async (selectInitial = false) => { setIsLoadingFlowList(true); setContextMenu(null); let firstFlowIdToLoad: number | string | null = null; try { const url = filterCampaignId === 'all' ? '/api/flows' : filterCampaignId === 'none' ? '/api/flows?campaignId=null' : `/api/flows?campaignId=${filterCampaignId}`;
        const response = await fetch(url); if (!response.ok) { const err = await response.json(); throw new Error(err.message || 'Falha ao buscar fluxos'); } const data: FlowData[] = await response.json(); setFlowsList(data); const currentSelectedExistsInNewList = data.some(f => f.id === selectedFlow?.id); if (data.length === 0) { if (selectedFlow !== null) { setSelectedFlow(null); setNodes([]); setEdges([]); setFlowNameInput(''); setSelectedCampaignId(null); setInitialFlowLoaded(false); } } else if (selectedFlow && !currentSelectedExistsInNewList) { setSelectedFlow(null); setNodes([]); setEdges([]); setFlowNameInput(''); setSelectedCampaignId(null); setInitialFlowLoaded(false); if (selectInitial) { firstFlowIdToLoad = data.find(f => f.status === 'active')?.id || data[0].id; } } else if (!selectedFlow && selectInitial) { firstFlowIdToLoad = data.find(f => f.status === 'active')?.id || data[0].id; } else if (selectedFlow && currentSelectedExistsInNewList) { const updatedData = data.find(f => f.id === selectedFlow.id); if (updatedData && (updatedData.name !== selectedFlow.name || updatedData.campaign_id !== selectedFlow.campaign_id || updatedData.status !== selectedFlow.status)) { setSelectedFlow(prev => prev ? { ...prev, ...updatedData, elements: prev.elements } : null); setFlowNameInput(updatedData.name); setSelectedCampaignId(updatedData.campaign_id ?? null); } } if (firstFlowIdToLoad) { await loadFlow(firstFlowIdToLoad); } } catch (error: any) { console.error("[fetchFlows] Erro:", error); toast({ title: "Erro Lista Fluxos", description: error.message, variant: "destructive" }); setFlowsList([]); setSelectedFlow(null); setNodes([]); setEdges([]); setFlowNameInput(''); setSelectedCampaignId(null); setInitialFlowLoaded(false); if(reactFlowInstance) setTimeout(() => reactFlowInstance.fitView({duration: 200}), 50); } finally { setIsLoadingFlowList(false); } }, [filterCampaignId, selectedFlow, reactFlowInstance, toast, loadFlow, setNodes, setEdges, initialFlowLoaded]);
    const saveFlow = useCallback(async () => { if (!selectedFlow || isSaving || !flowNameInput.trim() || !reactFlowInstance) return; setIsSaving(true); try { const currentNodes = reactFlowInstance.getNodes(); const currentEdges = reactFlowInstance.getEdges(); const nodesToSave = currentNodes.map(({ dragHandle, ...node }) => node); const flowToSave = { name: flowNameInput.trim(), campaign_id: selectedCampaignId || null, status: selectedFlow.status || 'draft', elements: { nodes: nodesToSave, edges: currentEdges } }; const response = await fetch(`/api/flows?id=${selectedFlow.id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(flowToSave) });
        if (!response.ok) { const err = await response.json(); throw new Error(err.message || 'Falha ao salvar'); } toast({ title: "Fluxo Salvo!" }); const updatedFlow = await response.json(); setSelectedFlow(updatedFlow); setFlowsList(prev => prev.map(f => f.id === updatedFlow.id ? updatedFlow : f)); } catch (error: any) { toast({ title: "Erro ao Salvar", description: error.message, variant: "destructive" }); } finally { setIsSaving(false); } }, [selectedFlow, flowNameInput, selectedCampaignId, reactFlowInstance, toast, isSaving]);
    const createNewFlow = useCallback(async () => { if (isLoadingFlowList || isLoadingFlowDetails || isSaving) return; const newFlowName = prompt("Nome do Novo Fluxo:", "Novo Fluxo"); if (!newFlowName || !newFlowName.trim()) return; setIsLoadingFlowDetails(true); try { const campaignIdToSend = filterCampaignId === 'all' || filterCampaignId === 'none' ? null : filterCampaignId; const response = await fetch('/api/flows', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name: newFlowName.trim(), campaign_id: campaignIdToSend }) });
        if (!response.ok) { const err = await response.json(); throw new Error(err.message || 'Falha ao criar'); } const createdFlow: FlowData = await response.json(); toast({ title: "Fluxo Criado!" }); setInitialFlowLoaded(false); await fetchFlows(false); await loadFlow(createdFlow.id); } catch (error: any) { toast({ title: "Erro ao Criar", description: error.message, variant: "destructive" }); } finally { setIsLoadingFlowDetails(false); } }, [toast, filterCampaignId, fetchFlows, loadFlow, isLoadingFlowList, isLoadingFlowDetails, isSaving]);
    const deleteSelectedFlow = useCallback(async () => { if (!selectedFlow || isDeleting || isLoadingFlowList || isLoadingFlowDetails || isSaving) return; if (!confirm(`Tem certeza que deseja deletar o fluxo "${selectedFlow.name}"? Esta ação não pode ser desfeita.`)) return; setIsDeleting(true); try { const response = await fetch(`/api/flows?id=${selectedFlow.id}`, { method: 'DELETE' });
        if (!response.ok) { let errMsg = 'Falha ao deletar'; try { errMsg = (await response.json()).message || errMsg } catch(e){} throw new Error(errMsg); } toast({ title: "Fluxo Deletado" }); setSelectedFlow(null); setNodes([]); setEdges([]); setFlowNameInput(''); setSelectedCampaignId(null); setInitialFlowLoaded(false); await fetchFlows(true); } catch (error: any) { toast({ title: "Erro ao Deletar", description: error.message, variant: "destructive" }); } finally { setIsDeleting(false); } }, [selectedFlow, toast, fetchFlows, setNodes, setEdges, isDeleting, isLoadingFlowList, isLoadingFlowDetails, isSaving]);
    const toggleFlowStatus = useCallback(async () => { if (!selectedFlow || isTogglingStatus || isLoadingFlowList || isLoadingFlowDetails || isSaving) return; setIsTogglingStatus(true); const newStatus = selectedFlow.status === 'active' ? 'inactive' : 'active'; try { const response = await fetch(`/api/flows?id=${selectedFlow.id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ status: newStatus }) });
        if (!response.ok) { const err = await response.json(); throw new Error(err.message || 'Falha ao alterar status'); } const updatedFlow = await response.json(); toast({ title: `Fluxo ${newStatus === 'active' ? 'Ativado' : 'Desativado'}` }); setSelectedFlow(updatedFlow); setFlowsList(prev => prev.map(f => f.id === updatedFlow.id ? updatedFlow : (newStatus === 'active' ? {...f, status: 'inactive'} : f) )); if (newStatus === 'active') { fetch('/api/whatsapp/reload-flow', { method: 'POST' }).catch(err => console.error("Erro ao solicitar reload-flow:", err)); } } catch (error: any) { toast({ title: "Erro Status", description: error.message, variant: "destructive" }); } finally { setIsTogglingStatus(false); } }, [selectedFlow, toast, isTogglingStatus, isLoadingFlowList, isLoadingFlowDetails, isSaving]);
    const onConnect: OnConnect = useCallback((connection) => { const sourceHandleId = connection.sourceHandle || 'source-bottom'; const isMultipleOutputHandle = sourceHandleId.startsWith('btn_') || sourceHandleId.startsWith('row_') || sourceHandleId.startsWith('list-item-'); const isStandardOutputHandle = ['source-bottom', 'source-success', 'source-received', 'source-timeout', 'source-true', 'source-false', 'source-error', 'source-fallback', 'source-inside', 'source-outside', 'source-loop-body', 'source-finished'].includes(sourceHandleId); if (!isMultipleOutputHandle && isStandardOutputHandle) { const existingEdge = edges.find(e => e.source === connection.source && e.sourceHandle === sourceHandleId); if (existingEdge) { setEdges((eds) => addEdge({ ...connection, markerEnd: { type: MarkerType.ArrowClosed, color: NEON_COLOR }, style: { stroke: NEON_COLOR, strokeWidth: 1.5 } }, eds.filter(e => !(e.source === connection.source && e.sourceHandle === sourceHandleId)))); return; } } setEdges((eds) => addEdge({ ...connection, markerEnd: { type: MarkerType.ArrowClosed, color: NEON_COLOR }, style: { stroke: NEON_COLOR, strokeWidth: 1.5 } }, eds)); }, [setEdges, edges]);
    const handleNodeContextMenu = useCallback((event: React.MouseEvent, node: Node) => { event.preventDefault(); if (isLoadingFlowDetails || isSaving) return; const reactFlowBounds = reactFlowWrapper.current?.getBoundingClientRect(); if (reactFlowBounds) { setContextMenu({ id: node.id, top: event.clientY - reactFlowBounds.top, left: event.clientX - reactFlowBounds.left, nodeType: node.type, }); } }, [isLoadingFlowDetails, isSaving]);
    const handlePaneClick = useCallback(() => setContextMenu(null), []);
    const handleDeleteNode = useCallback((nodeId: string) => { if (isLoadingFlowDetails || isSaving) return; setNodes((nds) => nds.filter((node) => node.id !== nodeId)); setEdges((eds) => eds.filter((edge) => edge.source !== nodeId && edge.target !== nodeId)); setContextMenu(null); }, [setNodes, setEdges, isLoadingFlowDetails, isSaving]);
    const handleDuplicateNode = useCallback((nodeId: string) => { if (isLoadingFlowDetails || isSaving || !reactFlowInstance) return; const nodeToDuplicate = reactFlowInstance.getNode(nodeId); if (!nodeToDuplicate) return; const newNodeId = `node_${nodeToDuplicate.type}_${Date.now()}_${Math.random().toString(16).substring(2, 8)}`; const position = { x: nodeToDuplicate.position.x + 30, y: nodeToDuplicate.position.y + 30 }; let newData = JSON.parse(JSON.stringify(nodeToDuplicate.data)); if (nodeToDuplicate.type === 'buttonMessage' && newData.buttons) { newData.buttons = newData.buttons.map((btn: ButtonOption) => ({ ...btn, id: `btn_${Date.now()}_${Math.random().toString(16).substring(2, 6)}` })); } if (nodeToDuplicate.type === 'listMessage' && newData.sections) { newData.sections = newData.sections.map((sec: ListSection) => ({ ...sec, id: `sec_${Date.now()}_${Math.random().toString(16).substring(2, 6)}`, rows: sec.rows.map((row: ListItem) => ({ ...row, id: `row_${Date.now()}_${Math.random().toString(16).substring(2, 6)}` })) })); } const newNode: Node = { ...nodeToDuplicate, id: newNodeId, position, data: newData, dragHandle: '.node-header' }; reactFlowInstance.addNodes(newNode); setContextMenu(null); }, [reactFlowInstance, isLoadingFlowDetails, isSaving]);
    const addNode = useCallback((type: keyof typeof nodeTypes) => {
        if (!reactFlowInstance || isLoadingFlowDetails || isSaving || !selectedFlow) { toast({ title: "Ação Indisponível", description: "Selecione um fluxo ou aguarde o carregamento.", variant: "destructive" }); return; }
        const reactFlowBounds = reactFlowWrapper.current?.getBoundingClientRect();
        const pane = reactFlowWrapper.current?.querySelector('.react-flow__pane');
        if (!reactFlowBounds || !pane) return;
        const { x: viewX, y: viewY, zoom } = reactFlowInstance.getViewport();
        const paneRect = pane.getBoundingClientRect(); const centerX = (paneRect.width / 2 - viewX) / zoom; const centerY = (paneRect.height / 2 - viewY) / zoom; const position = { x: centerX, y: centerY }; const newNodeId = `node_${type}_${Date.now()}_${Math.random().toString(16).substring(2, 8)}`; let newNodeData: any = {};
        switch (type) {
            case 'textMessage': newNodeData = { text: '' }; break;
            case 'buttonMessage': newNodeData = { text: '', buttons: [{ id: `btn_${Date.now()}`, text: 'Opção 1' }] }; break;
            case 'imageMessage': newNodeData = { url: '' }; break;
            case 'delay': newNodeData = { duration: 1, unit: 'seconds' }; break;
            case 'listMessage': newNodeData = { buttonText: 'Opções', title: 'Título', text: 'Escolha:', sections: [{ id: `sec_${Date.now()}`, title: 'Seção 1', rows: [{ id: `row_${Date.now()}`, title: 'Item 1' }] }] }; break;
            case 'waitInput': newNodeData = { variableName: 'userInput', message: '', timeoutSeconds: 60 }; break;
            case 'setVariable': newNodeData = { variableName: 'myVar', value: '' }; break;
            case 'condition': newNodeData = { variableName: '', comparison: 'equals', value: '' }; break;
            case 'apiCall': newNodeData = { apiUrl: '', method: 'GET', saveResponseTo: '' }; break;
            case 'assignAgent': newNodeData = { department: '', message: '' }; break;
            case 'endFlow': newNodeData = {}; break;
            case 'goToFlow': newNodeData = { targetFlowId: '' }; break;
            case 'tagContact': newNodeData = { tagName: '', action: 'add' }; break;
            case 'audioMessage': newNodeData = { url: '', caption: '' }; break;
            case 'fileMessage': newNodeData = { url: '', filename: '' }; break;
            case 'locationMessage': newNodeData = { latitude: '', longitude: '' }; break;
            case 'timeCondition': newNodeData = { startTime: '09:00', endTime: '18:00' }; break;
            case 'loopNode': newNodeData = { repetitions: 3 }; break;
            case 'webhookCall': newNodeData = { url: '', method: 'POST', headers: '', body: '', saveResponseTo: '' }; break;
            case 'gptQuery': newNodeData = { prompt: '', apiKeyVariable: 'OPENAI_API_KEY', saveResponseTo: 'gptResponse' }; break;
            default: break;
        }
        const nodeToAdd: Node = { id: newNodeId, type, position, data: newNodeData, dragHandle: '.node-header' };
        reactFlowInstance.addNodes(nodeToAdd);
        setTimeout(() => { reactFlowInstance.setCenter(position.x, position.y, { zoom: reactFlowInstance.getZoom(), duration: 300 }); }, 50);
    }, [reactFlowInstance, isLoadingFlowDetails, isSaving, nodeTypes, selectedFlow, toast]);
    // --- FIM FUNÇÕES E HOOKS ---


    // --- useEffects para carregar dados ---
    useEffect(() => { fetchCampaigns(); }, [fetchCampaigns]);
    useEffect(() => { fetchFlows(true); }, [filterCampaignId, fetchFlows]); // fetchFlows como dependência

    const isLoading = isLoadingFlowList || isLoadingFlowDetails || isSaving || isDeleting || isTogglingStatus;

    return (
        <TooltipProvider delayDuration={0}>
            <div className="flex flex-col h-screen bg-[#1a1a1a] text-white">
                {/* Barra Superior Fixa */}
                <div className="flex items-center justify-between p-2 border-b flex-shrink-0 gap-2 bg-[#141414] border-b-[#1E90FF]/20 sticky top-0 z-20">
                    <Link href="/zap" passHref>
                        <Button variant="ghost" size="sm" className={cn(baseButtonSelectStyle, "h-8 px-3 rounded")}>
                            <ArrowLeft className="mr-2 h-4 w-4" /> Voltar ao Dashboard
                        </Button>
                    </Link>
                    <h1 className="text-lg font-bold" style={{ textShadow: `0 0 6px ${NEON_COLOR}` }}>
                        Editor de Fluxos
                    </h1>
                    <div className="w-40"> {/* Placeholder para alinhar título */}</div>
                </div>

                {/* Conteúdo Principal (Editor) */}
                <div className="flex flex-grow overflow-hidden min-h-0">
                    {/* Barra Lateral de Nós */}
                     <div className={cn("w-48 p-2 flex-shrink-0 flex flex-col space-y-1.5 border-r overflow-y-auto custom-scrollbar", baseCardStyle, 'rounded-none border-r-[#1E90FF]/20 relative z-10')}>
                        <h3 className="text-sm font-semibold text-center text-white border-b border-[#1E90FF]/20 pb-1 mb-1 sticky top-0 z-10" style={{ textShadow: `0 0 5px ${NEON_COLOR}`, background: 'rgba(20, 20, 20, 0.8)', backdropFilter: 'blur(3px)' }}>
                            Adicionar Nó
                        </h3>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('textMessage')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={MessageSquare} className="mr-1.5 h-3.5 w-3.5"/> Texto</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('buttonMessage')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={ListChecks} className="mr-1.5 h-3.5 w-3.5"/> Botões</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('listMessage')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={ListChecks} className="mr-1.5 h-3.5 w-3.5 text-cyan-400"/> Lista</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('imageMessage')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={ImageIcon} className="mr-1.5 h-3.5 w-3.5"/> Imagem</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('audioMessage')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Mic} className="mr-1.5 h-3.5 w-3.5"/> Áudio</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('fileMessage')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={FileIcon} className="mr-1.5 h-3.5 w-3.5"/> Arquivo</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('locationMessage')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={MapPin} className="mr-1.5 h-3.5 w-3.5"/> Localização</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('delay')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Clock} className="mr-1.5 h-3.5 w-3.5"/> Atraso</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('waitInput')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={HelpCircle} className="mr-1.5 h-3.5 w-3.5"/> Esperar Input</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('setVariable')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Variable} className="mr-1.5 h-3.5 w-3.5"/> Definir Var</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('condition')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Waypoints} className="mr-1.5 h-3.5 w-3.5"/> Condição</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('timeCondition')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Clock} className="mr-1.5 h-3.5 w-3.5 text-purple-400"/> Cond. Horário</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('loopNode')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Repeat} className="mr-1.5 h-3.5 w-3.5"/> Loop</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('webhookCall')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Webhook} className="mr-1.5 h-3.5 w-3.5"/> Webhook</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('gptQuery')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Sparkles} className="mr-1.5 h-3.5 w-3.5"/> Consulta GPT</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('apiCall')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={RadioTower} className="mr-1.5 h-3.5 w-3.5"/> API Call</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('tagContact')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Target} className="mr-1.5 h-3.5 w-3.5"/> Tag Contato</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('goToFlow')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Workflow} className="mr-1.5 h-3.5 w-3.5"/> Ir p/ Fluxo</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('assignAgent')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={UserCheck} className="mr-1.5 h-3.5 w-3.5"/> Atribuir Agente</Button>
                        <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded !text-red-400 hover:!bg-red-500/30")} onClick={() => addNode('endFlow')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={LogOut} className="mr-1.5 h-3.5 w-3.5"/> Encerrar</Button>
                    </div>

                    {/* Área Principal do Editor */}
                    <div className="flex-grow flex flex-col bg-[#1a1a1a] min-w-0">
                        {/* Barra de Controles do Fluxo */}
                        <div className={cn("flex items-center justify-between p-2 border-b flex-shrink-0 gap-2", baseCardStyle, 'rounded-none border-b-[#1E90FF]/20 relative z-10')}>
                             <div className='flex items-center gap-1.5'>
                                 <Select value={filterCampaignId} onValueChange={setFilterCampaignId} disabled={isLoading}> <SelectTrigger className={cn(baseButtonSelectStyle, "w-[150px] h-8 px-2 text-xs rounded")}> <Filter className='h-3 w-3 mr-1 text-gray-400' style={{ filter: `drop-shadow(0 0 3px ${NEON_COLOR}50)` }}/> <SelectValue placeholder="Filtrar Campanha..." /> </SelectTrigger> <SelectContent className={cn(popoverContentStyle, "text-xs")}> <SelectItem value="all" className="text-xs hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]">Todos Fluxos</SelectItem> <SelectItem value="none" className="text-xs text-muted-foreground hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]">Sem Campanha</SelectItem> {campaignList.map(c => (<SelectItem key={c.id} value={c.id} className="text-xs hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]">{c.name}</SelectItem>))} </SelectContent> </Select>
                                 <Select onValueChange={(v) => loadFlow(v)} value={selectedFlow?.id?.toString() || ''} disabled={flowsList.length === 0 || isLoading}> <SelectTrigger className={cn(baseButtonSelectStyle, "w-[180px] h-8 px-2 text-xs rounded")}> <SelectValue placeholder={isLoadingFlowList ? "Carregando..." : (flowsList.length === 0 ? "Nenhum fluxo" : "Selecione Fluxo...")} /> </SelectTrigger> <SelectContent className={cn(popoverContentStyle)}> {flowsList.map(f => (<SelectItem key={f.id} value={f.id.toString()} className="text-xs flex justify-between items-center hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]"><span>{f.name}</span> {f.status === 'active' && <Badge variant="default" className='ml-2 px-1 py-0 text-[8px] h-4 bg-green-600/80 border-green-400/50 text-white'>Ativo</Badge>}</SelectItem>))} </SelectContent> </Select>
                             </div>
                             <div className="flex items-center gap-1.5 flex-grow justify-end">
                                 {selectedFlow && !isLoadingFlowDetails && ( <> <Select value={selectedCampaignId || 'none'} onValueChange={(v) => setSelectedCampaignId(v === 'none' ? null : v)} disabled={isLoading}> <SelectTrigger className={cn(baseButtonSelectStyle, "w-[150px] h-8 px-2 text-xs rounded")}> <Layers className='h-3 w-3 mr-1 text-gray-400' style={{ filter: `drop-shadow(0 0 3px ${NEON_COLOR}50)` }}/> <SelectValue placeholder="Vincular Campanha..." /> </SelectTrigger> <SelectContent className={cn(popoverContentStyle)}> <SelectItem value="none" className="text-xs text-muted-foreground hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]">Sem Campanha</SelectItem> {campaignList.map(c => (<SelectItem key={c.id} value={c.id} className="text-xs hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]">{c.name}</SelectItem>))} </SelectContent> </Select> <Input value={flowNameInput} onChange={(e) => setFlowNameInput(e.target.value)} placeholder="Nome do Fluxo" className={cn(baseInputInsetStyle, "h-8 text-xs w-[150px] rounded px-2")} disabled={isLoading} /> <Tooltip><TooltipTrigger asChild><Button onClick={toggleFlowStatus} variant="ghost" size="icon" className={cn(baseButtonSelectStyle, "w-8 h-8 rounded")} disabled={isLoading}>{isTogglingStatus ? <Activity className="h-4 w-4 animate-spin" style={{ filter: `drop-shadow(0 0 4px ${NEON_COLOR})` }}/> : (selectedFlow.status === 'active' ? <Square className="h-4 w-4 text-red-500" style={{ filter: `drop-shadow(0 0 3px #ef4444)` }}/> : <Play className="h-4 w-4 text-green-500" style={{ filter: `drop-shadow(0 0 3px #22c55e)` }}/>)}</Button></TooltipTrigger><TooltipContent className={cn(popoverContentStyle, 'text-xs')}>{selectedFlow.status === 'active' ? 'Desativar Fluxo' : 'Ativar Fluxo'}</TooltipContent></Tooltip> <Tooltip><TooltipTrigger asChild><Button onClick={saveFlow} variant="ghost" size="icon" className={cn(baseButtonSelectStyle, "w-8 h-8 rounded")} disabled={isLoading || !flowNameInput.trim()}>{isSaving ? <Activity className="h-4 w-4 animate-spin" style={{ filter: `drop-shadow(0 0 4px ${NEON_COLOR})` }}/> : <Save className="h-4 w-4" style={{ filter: `drop-shadow(0 0 3px ${NEON_COLOR})` }}/>}</Button></TooltipTrigger><TooltipContent className={cn(popoverContentStyle, 'text-xs')}>Salvar Fluxo</TooltipContent></Tooltip> <Tooltip><TooltipTrigger asChild><Button onClick={deleteSelectedFlow} variant="ghost" size="icon" className={cn(baseButtonSelectStyle, "w-8 h-8 rounded !text-red-400 hover:!bg-red-500/30")} disabled={isLoading}>{isDeleting ? <Activity className="h-4 w-4 animate-spin" style={{ filter: `drop-shadow(0 0 4px #ef4444)` }}/> : <IconTrash className="h-4 w-4" style={{ filter: `drop-shadow(0 0 3px #ef4444)` }}/>}</Button></TooltipTrigger><TooltipContent className={cn(popoverContentStyle, 'text-xs')}>Deletar Fluxo</TooltipContent></Tooltip> </> )}
                                 {!selectedFlow && !isLoadingFlowList && !isLoadingFlowDetails && <span className='text-xs text-gray-400 mr-2' style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}>Selecione ou crie um fluxo</span>}
                                 {(isLoadingFlowList || isLoadingFlowDetails) && <Activity className="h-4 w-4 animate-spin text-gray-400 mr-2" style={{ filter: `drop-shadow(0 0 4px ${NEON_COLOR}50)` }}/>}
                             </div>
                            <Button onClick={createNewFlow} className={cn(baseButtonSelectStyle, `hover:!bg-[${NEON_COLOR}]/30 h-8 text-xs px-3 rounded`)} disabled={isLoading}> <Plus className="mr-1 h-4 w-4" style={{ filter: `drop-shadow(0 0 3px ${NEON_COLOR})` }}/> Novo </Button>
                        </div>

                        {/* Canvas ReactFlow */}
                        <div className="flex-grow relative h-full" ref={reactFlowWrapper}>
                             {reactFlowInstance ? (
                                <ReactFlow
                                    nodes={nodes} edges={edges} onNodesChange={onNodesChange} onEdgesChange={onEdgesChange}
                                    onConnect={onConnect} nodeTypes={nodeTypes} fitView={!initialFlowLoaded}
                                    fitViewOptions={{ padding: 0.3 }} className="bg-transparent" proOptions={{ hideAttribution: true }}
                                    deleteKeyCode={['Backspace', 'Delete']} onNodeContextMenu={handleNodeContextMenu} onPaneClick={handlePaneClick}
                                    nodesDraggable={!isLoading && !!selectedFlow} nodesConnectable={!isLoading && !!selectedFlow}
                                    elementsSelectable={!isLoading && !!selectedFlow} >
                                    <Controls className={cn(baseButtonSelectStyle, '!border-none !shadow-none flex flex-col gap-0.5 !bg-opacity-80 backdrop-blur-sm')} />
                                    <MiniMap className={cn(baseCardStyle, '!border-[#1E90FF]/20 rounded-md overflow-hidden')} nodeStrokeWidth={3} zoomable pannable nodeColor="#1E90FF80" maskColor="rgba(26,26,26,0.7)" />
                                    <Background variant={BackgroundVariant.Dots} gap={16} size={1} className={`!stroke-[#1E90FF]/15`} />
                                    {contextMenu && <NodeContextMenu id={contextMenu.id} top={contextMenu.top} left={contextMenu.left} nodeType={contextMenu.nodeType} onClose={handlePaneClick} onDelete={handleDeleteNode} onDuplicate={handleDuplicateNode} />}
                                </ReactFlow>
                             ) : ( <div className="flex items-center justify-center h-full text-gray-400" style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}> Carregando editor... </div> )}
                             {isLoading && <div className="absolute inset-0 bg-black/70 flex items-center justify-center text-white z-10 backdrop-blur-sm"><Activity className="h-6 w-6 animate-spin mr-2" style={{ filter: `drop-shadow(0 0 5px ${NEON_COLOR})` }}/> Processando...</div>}
                             {!selectedFlow && !isLoading && <div className="absolute inset-0 bg-black/70 flex items-center justify-center text-white z-10 backdrop-blur-sm text-sm" style={{ textShadow: `0 0 4px ${NEON_COLOR}` }}>Selecione ou crie um fluxo para começar.</div>}
                        </div>
                    </div>
                </div>
            </div>
        </TooltipProvider>
    );
}

// --- Wrapper da Página com Provider ---
export default function FlowPage() {
    return (
        <ReactFlowProvider>
            <FlowEditorPage />
        </ReactFlowProvider>
    );
}